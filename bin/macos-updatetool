#!/bin/zsh

LOGO=(
 " â–ˆâ–€â–„â–€â–ˆ â–„â–€â–€â–„ â–„â–€â–€â–„ â–„â–€â–€â–„ â–ˆâ–€â–€    â–ˆ  â–ˆ â–„â–€â–€â–„ â–ˆâ–€â–€â–„ â–„â–€â–€â–„ â–€â–ˆâ–€ â–ˆâ–€â–€ â–€â–ˆâ–€ â–„â–€â–€â–„ â–„â–€â–€â–„ â–ˆ  "
 " â–ˆ â–€ â–ˆ â–ˆâ–„â–„â–ˆ â–ˆ  â–„ â–ˆ  â–ˆ â–€â–€â–„ â–€â–€ â–ˆ  â–ˆ â–ˆâ–„â–„â–ˆ â–ˆ  â–ˆ â–ˆâ–„â–„â–ˆ  â–ˆ  â–ˆâ–€â–€  â–ˆ  â–ˆ  â–ˆ â–ˆ  â–ˆ â–ˆ  "
 " â–€   â–€ â–€  â–€  â–€â–€   â–€â–€  â–€â–€â–€     â–€â–€â–€ â–ˆ    â–€â–€â–€  â–€  â–€  â–€  â–€â–€â–€  â–€   â–€â–€   â–€â–€  â–€â–€â–€"
)
# A CLI tool that manages apps and packages on macOS.
# It handles Homebrew, npm, App Store apps, and Xcode components.
# Author:
#   John Valai <git@jvk.to>
# License:
#   MIT License
#
# It can upgrade or install applications from multiple sources:
#   * App Store (using mas)
#   * npm
#   * Homebrew (both formulas and casks)
#
# Configuration:
#   * It relies on a file named `applist` (located in the same directory) to know which
#     specific applications and packages to manage.
#
# Dependencies:
#   * Homebrew: For managing formulas and casks.
#   * mas-cli: For managing Mac App Store applications.
#   * npm: For managing global Node.js packages.
#   * Oh My Zsh & zinit: For managing Zsh configuration.
#   * pip3: For managing python packages.
#   * Xcode Command Line Tools: MacOS tool for compiling and installing software.`
#   * softwareupdate: Built-in MacOS tool for system updates.
#
# Usage:
#   * Run it with different flags to perform specific actions, for example:
#     -h, help: To see all available options.
#     -l, list, list-all: To list all the apps.
#     list-npm: Lists all npm packages.
#     list-brew-formulas, list-formulas: Lists all brew formulas.
#     list-brew-casks, list-casks: Lists all brew casks.
#     list-appstore Lists all App Store applications.
#     list-xcode: Lists Xcode info.
#     list-xcode-tools: Lists Xcode Command Line Tools info.
#     outdated: Use with list-* to show only outdated packages.
#     update-formulas: Upgrade Homebrew formulas.
#     update-npm: Upgrade npm packages.
#     update-casks: Upgrade Homebrew casks.
#     update-appstore: Upgrade Mac App Store apps.
#     update-xcode: Upgrade Xcode.
#     update-xcode-tools: Upgrade Xcode Command Line Tools.
#     install-formulas: Install Homebrew formulas.
#     install-npm: Install npm packages.
#     install-casks: Install Homebrew casks.
#     install-appstore: Install Mac App Store apps.
#     install-xcode: Install Xcode.
#     install-xcode-tools: Install Xcode Command Line Tools.
#     update-all: Perform ALL updates in sequence.
#     install-all: Perform ALL installations in sequence.
#     completions: Generate zsh completion script.
#     -a, add <app> <category>: Add an app to the applist.
#     -r, remove <app> <category>: Remove an app from the applist.

# Source the styles and helper utilities
source "${0:A:h}/styles.zsh"
source "${0:A:h}/helpers.sh"

# Define the path to the applist file, which should contain the lists of apps to be managed.
APPLIST="$HOME/.config/macos-updatetool/applist.yaml"

# Manages the applist.yaml file.
# Acceptable categories are: appstore_apps, npm_apps, brew_formulas, brew_casks
# @param {string} action - The action to perform ("add" or "remove")
# @param {string} app_name - The name of the application
# @param {string} category - The category ("appstore", "npm", "brew", "cask")
# @returns {number} 0 on success, 1 on error
manage_applist() {
  local action="$1" app_name="$2" category="$3"
  local valid_categories=("appstore" "npm" "brew" "cask")
  local key="${category}_apps"

  # Validate action
  if [[ "$action" != "add" && "$action" != "remove" ]]; then
    msg_error "Invalid action '$action' â€” use 'add' or 'remove'." >&2
    return 1
  fi

  # Validate category
  if [[ ! " ${valid_categories[*]} " =~ " ${category} " ]]; then
    msg_error --color "Invalid category '$category'. Must be one of: ${valid_categories[*]}." >&2
    return 1
  fi

  # Existence check (strip quotes from YAML output)
  if yq ".${key}[]" "$APPLIST" \
     | sed "s/^['\"]//; s/['\"]$//" \
     | grep -Fxq "$app_name"; then
    if [[ "$action" == "add" ]]; then
      msg_warning "'$app_name' already exists in '$category'. Skipping."
      return 0
    fi
  else
    if [[ "$action" == "remove" ]]; then
      msg_warning "'$app_name' not found in '$category'. Nothing to remove."
      return 0
    fi
  fi

  # Perform action with proper quoting
  if [[ "$action" == "add" ]]; then
    yq -i '
      .'"${key}"' += ["'"${app_name}"'"] |
      .'"${key}"'[-1] style="single"
    ' "$APPLIST" \
    && msg_success "Added '$app_name' to '$category'."
  else
    yq -i '
      del(.'"${key}"'[] | select(. == "'"${app_name}"'"))
    ' "$APPLIST" \
    && msg_success "Removed '$app_name' from '$category'."
  fi
}

# Creates a default applist.yaml file with common applications
# @returns {number} 0 on success, 1 on error
create_default_applist() {
  local applist_dir="$(dirname "$APPLIST")"
  
  # Create directory if it doesn't exist
  if [ ! -d "$applist_dir" ]; then
    if ! mkdir -p "$applist_dir"; then
      msg_error "Failed to create directory: $applist_dir"
      return 1
    fi
  fi

  # Create default applist.yaml
  cat > "$APPLIST" << 'EOF'
---
# macOS Application and Package List
# This file defines the apps and packages to be managed by macos-updatetool

# Mac App Store applications (use app names as they appear in the store)
appstore_apps:
# - 'Color Picker'
# - 'Command X'

# Global npm packages
npm_apps:
# - '@anthropic-ai/claude-code'
# - 'gemini-cli'

# Homebrew formulas (command-line tools)
brew_formulas:
# - 'git'
# - 'gh'
# - 'git-credential-manager'
# - 'python'

# Homebrew casks (GUI applications)
brew_casks:
#  - 'warp'
#  - 'iterm2'
EOF

  if [ $? -eq 0 ]; then
    msg_success "  Created default applist.yaml at: $APPLIST\n"
    msg_info "  You can now edit this file to customize your application list.\n"
    return 0
  else
    msg_error "Failed to create default applist.yaml\n"
    return 1
  fi
}

# Checks the applist file for existence, YAML validity, and required sections.
# @returns {number} 0 if all checks pass, 1 if any check fails
check_applist_file() {
  # Check for applist file existence
  if [ ! -f "$APPLIST" ]; then
    msg_error --color "Config Error: Applist file not found at <$APPLIST>" >&2
    echo
    msg_question --color "Would you like to create a default applist.yaml file? (y/N)"
    read -r response
    case "$response" in
      [yY][eE][sS]|[yY])
        if create_default_applist; then
          msg_success --color "Default applist.yaml created successfully!"
          echo
        else
          msg_error "Failed to create applist file. Exiting."
          exit 1
        fi
        ;;
      *)
        msg_info "Skipping applist creation. You can create it manually later.\n"
        msg_error --color "Cannot proceed without applist file. Exiting."
        exit 1
        ;;
    esac
  fi

  # Validate applist.yaml using yamllint
  if ! yamllint "$APPLIST" &> /dev/null; then
    msg_error --color "Config Error: Applist file at \`$APPLIST\` is not a valid YAML file. Please fix it." >&2
    exit 1
  fi

  # 3. Check if yq can parse the applist file and if required keys exist
  local -a required_keys=("appstore_apps" "npm_apps" "brew_formulas" "brew_casks")
  local -a missing_keys
  for key in "${required_keys[@]}"; do
    if ! yq -e ".${key}" "$APPLIST" &> /dev/null; then
      missing_keys+=("$key")
    fi
  done

  if [[ ${#missing_keys[@]} -gt 0 ]]; then
    msg_error "Config Error: The following keys are not defined or are empty in the applist file:" >&2
    for key in "${missing_keys[@]}"; do
      msg_bullet "  $key" >&2
    done
    exit 1
  fi
  msg_success "YAML Config <$APPLIST> checks OK."
}

# Checks for all required dependencies, including the Zsh environment.
# If any are missing, it prints an error and exits.
# @returns {number} 0 if all dependencies are available, 1 if any are missing
check_dependencies() {
  # Check for Zsh environment
  if [ -z "$ZSH_VERSION" ]; then
    msg_error "Error: This script is designed to be run with Zsh.\n" >&2
    return 1
  fi
  # Check required CLI tools
  local -a missing_deps
  local -a dependencies=("brew" "mas" "npm" "pip3" "xcode-select" "yq")

  # Check Oh My Zsh installation
  if [[ ! -d "$HOME/.oh-my-zsh" ]] && [[ ! -f "$HOME/.oh-my-zsh/oh-my-zsh.sh" ]]; then
    missing_deps+=("omz (Oh My Zsh)")
  fi
  
  # Check Zinit installation
  if [[ ! -d "$HOME/.local/share/zinit" ]] && [[ ! -d "$HOME/.zinit" ]] && [[ ! -f "$HOME/.local/share/zinit/zinit.zsh" ]]; then
    missing_deps+=("zinit")
  fi

  for dep in "${dependencies[@]}"; do
    if ! command -v "$dep" &> /dev/null; then
      missing_deps+=("$dep")
    fi
  done

  if [[ ${#missing_deps[@]} -gt 0 ]]; then
    msg_error --color "Missing required command-line tools. Please install the following:" >&2
    for dep in "${missing_deps[@]}"; do
      msg_bullet "  ${STYLE[RED]}$dep" >&2
    done
    echo
    return 1
  fi

  msg_success "Dependencies check OK."
}






# Wrapper function for 'brew upgrade'.
# It prints a header and then executes the brew upgrade command.
br_upgrade() {
  printf "ðŸš€ Running: brew upgrade %s\n\n" "$*"
  brew -v upgrade $1 $2 $3 $4 $5 $6; _hr
}

# Wrapper function for 'brew install'.
# It prints a header and then executes the brew install command.
br_install() {
  printf "ðŸš€ Running: brew install %s\n\n" "$*"
  brew -v install $1 $2 $3 $4 $5 $6; _hr
}

# Generic command runner.
# It prints the command being run and then executes it using eval.
cmd_run() {
  printf "ðŸš€ Running: %s\n\n" "$*"
  eval "$1 $2 $3 $4 $5 $6"; _hr
}

# Prints a horizontal rule to visually separate sections of the output.
_hr() {
  echo -e "\n\e[1;34m$(printf '%*s\n\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -)\e[0m\n"
}







# Checks if App Store apps need updates and upgrades them
# @returns {number} 0 on success, 1 on error
update_appstore() {
  local -a appstore_apps=("${(@f)$(yq -r '.appstore_apps[]' "$APPLIST")}")
  msg_header --underline --upper "Updating App Store apps" "(${#appstore_apps[@]}):"
  echo
  show_spinner "  Updating $(style_wrap GREEN "mas")" "brew -v upgrade mas"
  echo

  for app in "${appstore_apps[@]}"; do
    show_spinner "  Updating $(style_wrap GREEN "${app}")" "mas upgrade \"${app}\""
  done

  # FINISH UP: Check for any remaining outdated apps and system updates.
  echo
  show_spinner --show-output "  Check for all outdated $(style_wrap GREEN "App Store") apps" "mas outdated"
  echo
  msg_info --italic "    These apps aren't in your applist.yaml and won't be auto-updated."
  echo
  show_spinner --show-output "  Check for $(style_wrap GREEN "MacOS") updates" "softwareupdate list"
}

# Installs applications from the Mac App Store.
# @returns {number} 0 on success, 1 on error
install_appstore_apps() {
  local -a appstore_apps=("${(@f)$(yq -r '.appstore_apps[]' "$APPLIST")}")
  msg_header --underline --upper "Installing App Store apps" "(${#appstore_apps[@]}):"
  echo
  for app in "${appstore_apps[@]}"; do
    show_spinner "  Installing $(style_wrap GREEN "${app}")" "mas install \"${app}\""
  done
}

# Upgrades globally installed npm packages.
# @returns {number} 0 on success, 1 on error
update_npm() {
  local -a npm_apps=("${(@f)$(yq -r '.npm_apps[]' "$APPLIST")}")
  msg_header --underline --upper "Updating NPM apps" "(${#npm_apps[@]}):"
  echo
  # Update npm itself
  show_spinner "  Updating $(style_wrap GREEN "npm") itself" "npm update -g npm"
  echo
  for app in "${npm_apps[@]}"; do
    show_spinner "  Updating $(style_wrap GREEN "${app}")" "npm update -g \"${app}\""
  done
  
  # FINISH UP: Run npm doctor to check for any issues.
  # ---------
  echo
  show_spinner --show-output "  Checking $(style_wrap GREEN "NPM health")" "npm doctor"
}

# Installs globally installed npm packages.
install_npm_apps() {
  local -a npm_apps=("${(@f)$(yq -r '.npm_apps[]' "$APPLIST")}")
  msg_header --underline --upper "Installing NPM apps" "(${#npm_apps[@]}):"
  echo
  for app in "${npm_apps[@]}"; do
    show_spinner "Installing $(style_wrap GREEN "${app}")" "npm install -g \"${app}\""
  done
  # FINISH UP: Run npm doctor to check for any issues.
  # ---------
  echo
  show_spinner --show-output "Checking $(style_wrap GREEN "NPM health")" "npm doctor"
}

# Upgrades Homebrew formulas.
update_formulas() {
  local -a brew_apps=("${(@f)$(yq -r '.brew_formulas[]' "$APPLIST")}")
  msg_header --underline --upper "Updating Brew formulas" "(${#brew_apps[@]}):"
  echo
  show_spinner "Updating Homebrew" "brew update"
  echo
  for app in "${brew_apps[@]}"; do
  	show_spinner "Upgrading $(style_wrap GREEN "${app}")" "brew upgrade \"${app}\""
  done
  # FINISH UP: Run brew doctor
  echo
  show_spinner --show-output "Checking $(style_wrap GREEN "Brew health")" "brew doctor"
}

# Installs Homebrew formulas.
# @returns {number} 0 on success, 1 on error
install_formulas() {
  local -a brew_apps=("${(@f)$(yq -r '.brew_formulas[]' "$APPLIST")}")
  msg_header --underline --upper "Installing Brew formulas" "(${#brew_apps[@]}):"
  echo
  show_spinner "Updating Homebrew" "brew update"
  echo
  for app in "${brew_apps[@]}"; do
  	show_spinner "Installing $(style_wrap GREEN "${app}")" "brew install \"${app}\""
  done
  # FINISH UP: Run brew doctor
  echo
  show_spinner --show-output "Checking $(style_wrap GREEN "Brew health")" "brew doctor"
}

# Upgrades Homebrew Casks.
# @returns {number} 0 on success, 1 on error
update_casks() {
  local -a cask_apps=("${(@f)$(yq -r '.brew_casks[]' "$APPLIST")}")
  msg_header --underline --upper "Upgrading Brew Casks" "(${#cask_apps[@]}):"
  echo
  msg_warning --italic "You may need to close the apps for updates to apply."
  echo
  
  show_spinner "Updating Homebrew" "brew update"
  echo
  for app in "${cask_apps[@]}";  do
  	show_spinner "Upgrading $(style_wrap GREEN "${app}")" "brew upgrade --cask \"${app}\""
  done
  # FINISH UP: Run brew doctor
  echo
  show_spinner --show-output "Checking $(style_wrap GREEN "Brew health")" "brew doctor"
}

# Installs Homebrew Casks.
# @returns {number} 0 on success, 1 on error
install_casks() {
  local -a cask_apps=("${(@f)$(yq -r '.brew_casks[]' "$APPLIST")}")
  msg_header --underline --upper "Installing Brew Casks" "(${#cask_apps[@]}):"
  echo
  
  for app in "${cask_apps[@]}"; do
  	show_spinner "Installing $(style_wrap GREEN "${app}")" "brew install --cask \"${app}\""
  done
  # FINISH UP: Run brew doctor
  echo
  show_spinner --show-output "Checking $(style_wrap GREEN "Brew health")" "brew doctor"
}

# Upgrades Command Line Tools for Xcode
# @returns {number} 0 on success, 1 on error
update_xcode_tools() {
  msg_header --underline --upper "\Updating Xcode Command Line Tools:"
  echo
  
  # Check if Command Line Tools are installed
  if ! xcode-select -p &> /dev/null; then
    msg_warning "Command Line Tools not installed. Exiting..."
    return 1
  fi
  
  # Check for and install any Command Line Tools updates
  local xcode_update_label
  xcode_update_label=$(softwareupdate list 2>/dev/null | grep -i "command line tools" | grep "Label:" | sed 's/^[[:space:]]*\*[[:space:]]*Label:[[:space:]]*//' || true)

  if [[ -n "$xcode_update_label" ]]; then
    msg_info "Found Command Line Tools to update: $xcode_update_label"
    show_spinner "Installing $(style_wrap GREEN "Command Line Tools") update" "softwareupdate --install \"$xcode_update_label\" --verbose" 120
  else
    msg_success "Command Line Tools are already up to date."
  fi
  
  # Show current version info
  echo
  msg_info "Current version: $(style_wrap GREEN "$(xcode-select --version)")"  
  msg_info "Current path: $(style_wrap GREEN "$(xcode-select --print-path)")"
}

# Upgrades Xcode
# @returns {number} 0 on success, 1 on error
update_xcode() {
  msg_header --underline --upper "\nUpdating Xcode:"
  echo
  
  # Check if Xcode is installed
  local xcode_info
  xcode_info=$(mas list | grep "^497799835 " || true)
  
  if [[ -z "$xcode_info" ]]; then
    msg_warning "Xcode is not installed. Use \`install-xcode\` to install it first."
    return 1
  fi
  
  # Upgrade Xcode
  show_spinner "Updating $(style_wrap GREEN "Xcode")" "mas upgrade 497799835"
  
  # Show current info
  echo
  msg_info "Current info: \n\n$(style_wrap GREEN "$(mas info 497799835)")"
}

# Installs Xcode
# @returns {number} 0 on success, 1 on error
install_xcode() {
  msg_header --underline --upper "\nInstalling Xcode:"
  echo
  
  # Check if Xcode is already installed
  local xcode_info
  xcode_info=$(mas list | grep "^497799835 " || true)
  
  if [[ -n "$xcode_info" ]]; then
    msg_success "Xcode is already installed."
    echo
    msg_info "Current $(style_wrap GREEN "Xcode") info:\n\n$(style_wrap GREEN "$(mas info 497799835)")"
    return 0
  fi
  
  # Install Xcode
  msg_warning --italic "Note: Xcode is a large download (several GB) and may take a long time."
  echo
  show_spinner -show-output "Installing $(style_wrap GREEN "Xcode")" "mas install 497799835" 0
  
  # Show installation info
  echo
  msg_info "Current $(style_wrap GREEN "Xcode") info:\n\n$(style_wrap GREEN "$(mas info 497799835)")"
}

# Lists App Store packages with status
# @param {boolean} show_outdated - Whether to show only outdated packages
list_appstore() {
  local show_outdated="$1"
  local -a appstore_apps=($(yq -r '.appstore_apps[]' "$APPLIST"))
  
  msg_header --underline --upper "\nShowing App Store Apps" "(${#appstore_apps[@]}):\n"

  # Check if there are any appstore apps defined
  if [[ ${#appstore_apps[@]} -eq 0 ]]; then
    msg_warning --color "  No App Store apps defined in applist.yaml"
    return 0
  fi

  # Get all installed and outdated apps at once with spinner
  local installed_list outdated_list
  local temp_installed=$(mktemp)
  local temp_outdated=$(mktemp)

  # Fetch installed apps
  show_spinner "Getting installed App Store apps" "mas list > '$temp_installed'"
  installed_list=$(cat "$temp_installed")
  rm -f "$temp_installed"

  # Fetch outdated apps
  show_spinner "Checking for outdated App Store apps" "mas outdated > '$temp_outdated'"
  outdated_list=$(cat "$temp_outdated")
  rm -f "$temp_outdated"

  # Arrays to group packages by status
  local -a uptodate_packages=()
  local -a outdated_packages=()
  local -a not_installed_packages=()

  # Categorize packages
  for app in "${appstore_apps[@]}"; do
    local installed_info=""
    installed_info=$(grep -i " ${app} " <<< "$installed_list" || true)

    if [[ -n "$installed_info" ]]; then
      local current_version="" is_outdated="" latest_version=""
      current_version=$(awk -F'[()]' '{print $2}' <<< "$installed_info")      
      is_outdated=$(grep -i " ${app} " <<< "$outdated_list" || true)

      if [[ -n "$is_outdated" ]]; then
        latest_version=$(awk -F'->' '{gsub(/[() ]/, "", $2); print $2}' <<< "$is_outdated")
        # Outdated
        outdated_packages+=("$app ${STYLE[YELLOW]}$current_version${STYLE[RESET]} ${SYMBOL[ARROW]} ${STYLE[LIGHT_GREEN]}$latest_version${STYLE[RESET]}")
      else
        # Up to date
        uptodate_packages+=("$app ${STYLE[LIGHT_GREEN]}$current_version${STYLE[RESET]}")
      fi
    else
      # Not installed
      not_installed_packages+=("$app")
    fi
  done

  # Display packages grouped by status
  echo

  # Show up-to-date packages
  if [[ "$show_outdated" != true ]]; then
    if [[ ${#uptodate_packages[@]} -gt 0 ]]; then
      msg_header h3 --upper "  Up-to-date" "(${#uptodate_packages[@]}):\n"
      for package in "${uptodate_packages[@]}"; do
        msg_success --bold "  $package"
      done
      echo
    fi
  fi

  # Show outdated packages
  if [[ ${#outdated_packages[@]} -gt 0 ]]; then
    msg_header h4 --upper "  Outdated" "(${#outdated_packages[@]}):\n"
    for package in "${outdated_packages[@]}"; do
      msg_warning "  $package"
    done
    echo
  elif [[ "$show_outdated" == true ]]; then
    msg_success --italic --color "  All App Store apps are up-to-date!"
    echo
  fi

  # Show not installed packages
  if [[ "$show_outdated" != true && ${#not_installed_packages[@]} -gt 0 ]]; then
    msg_header h5 --upper "  Not installed" "(${#not_installed_packages[@]}):\n"
    for package in "${not_installed_packages[@]}"; do
      msg_error --italic "  $package"
    done
  fi
}

# Lists npm packages with status
# @param {boolean} show_outdated - Whether to show only outdated packages
list_npm() {
  local show_outdated="$1"
  local -a npm_apps=($(yq -r '.npm_apps[]' "$APPLIST"))

  msg_header --underline --upper "\nShowing NPM Packages" "(${#npm_apps[@]}):\n"

  # Check if there are any npm packages defined
  if [[ ${#npm_apps[@]} -eq 0 ]]; then
    msg_warning --color "  No npm packages defined in applist.yaml"
    return 0
  fi

  # Get all npm packages info with spinners
  local installed_list outdated_list
  local temp_installed=$(mktemp)
  local temp_outdated=$(mktemp)

  # Fetch installed packages
  show_spinner "Getting installed npm packages" "npm list -g > '$temp_installed'"
  installed_list=$(cat "$temp_installed")
  rm -f "$temp_installed"

  # Fetch outdated packages
  show_spinner "Checking for outdated npm packages" "npm outdated -g > '$temp_outdated'"
  outdated_list=$(cat "$temp_outdated")
  rm -f "$temp_outdated"

  # Arrays to group packages by status
  local -a uptodate_packages=()
  local -a outdated_packages=()
  local -a not_installed_packages=()

  # Categorize packages
  for app in "${npm_apps[@]}"; do
    local installed_info=""
    installed_info=$(echo "$installed_list" | grep " ${app}@" || true)

    if [[ -n "$installed_info" ]]; then
      local current_version="" is_outdated="" latest_version=""
      # More robust version extraction for scoped and regular packages
      current_version=$(echo "$installed_info" | sed -n "s|.*${app}@\([^[:space:]]*\).*|\1|p" || true)
      is_outdated=$(echo "$outdated_list" | grep "^${app} " || true)

      if [[ -n "$is_outdated" ]]; then
        latest_version=$(echo "$is_outdated" | awk '{print $4}' || true)
        # Outdated
        outdated_packages+=("$app ${STYLE[RED]}$current_version${STYLE[RESET]} ${SYMBOL[ARROW]} ${STYLE[YELLOW]}$latest_version${STYLE[RESET]}")
      else
        # Up to date
        uptodate_packages+=("$app ${STYLE[GREEN]}$current_version${STYLE[RESET]}")
      fi
    else
      # Not installed
      not_installed_packages+=("$app")
    fi
  done

  # Display packages grouped by status
  echo

  # Show up-to-date packages
  if [[ "$show_outdated" != true ]]; then
    if [[ ${#uptodate_packages[@]} -gt 0 ]]; then
      msg_header h3 --upper "  Up-to-date" "(${#uptodate_packages[@]}):\n"
      for package in "${uptodate_packages[@]}"; do
        msg_success --bold "  $package"
      done
      echo
    fi
  fi

  # Show outdated packages
  if [[ ${#outdated_packages[@]} -gt 0 ]]; then
    msg_header h4 --upper "  Outdated" "(${#outdated_packages[@]}):\n"
    for package in "${outdated_packages[@]}"; do
      msg_warning --bold "  $package"
    done
    echo
  elif [[ "$show_outdated" == true ]]; then
    msg_success "  All npm packages are up-to-date!"
    echo
  fi

  # Show not installed packages
  if [[ "$show_outdated" != true && ${#not_installed_packages[@]} -gt 0 ]]; then
    msg_header h5 --upper "  Not installed" "(${#not_installed_packages[@]}):\n"
    for package in "${not_installed_packages[@]}"; do
      msg_error --italic "  $package"
    done
  fi  
}

# Lists brew formulas and casks with status
# @param {string} package_type - Type of package ("formulas" or "casks")
# @param {boolean} show_outdated - Whether to show only outdated packages
list_brew() {
  local package_type="$1" # "formula" or "cask"
  local show_outdated="$2"
  
  # Determine which app list to use and set appropriate variables
  local -a brew_apps
  if [[ "$package_type" == "cask" ]]; then
    brew_apps=($(yq -r '.brew_casks[]' "$APPLIST"))
  else
    brew_apps=($(yq -r '.brew_formulas[]' "$APPLIST"))
  fi

  local app_key
  local display_name
  app_key="brew_${package_type}s"
  display_name="Brew ${(C)package_type}s"

  msg_header --underline --upper "\nShowing ${display_name}" "(${#brew_apps[@]}):\n"

  # Check if there are any packages defined
  if [[ ${#brew_apps[@]} -eq 0 ]]; then
    msg_warning --color "  No ${display_name} defined in applist.yaml"
    return 0
  fi

  # Get outdated packages info with spinner
  local outdated_apps installed_apps
  local temp_outdated=$(mktemp)
  local temp_installed=$(mktemp)

  # Fetch outdated packages
  show_spinner "Checking for outdated ${package_type}s" "brew outdated --${package_type} > '$temp_outdated'"
  outdated_apps=$(cat "$temp_outdated")
  rm -f "$temp_outdated"

  # Fetch installed packages
  if [[ "$package_type" == "cask" ]]; then
    show_spinner "Getting installed ${package_type}" "brew list --cask --versions > '$temp_installed'"
  else
    show_spinner "Getting installed ${package_type}" "brew list --versions > '$temp_installed'"
  fi
  installed_apps=$(cat "$temp_installed")
  rm -f "$temp_installed"
  
  # Pre-fetch JSON data for all outdated packages that are in our list
  local brew_json=""
  if [[ -n "$outdated_apps" ]]; then
    local -a outdated_in_list=()
    for app in "${brew_apps[@]}"; do
      if echo "$outdated_apps" | grep -q "^${app}$"; then
        outdated_in_list+=("$app")
      fi
    done
    
    # Fetch JSON for all outdated packages at once with spinner
    if [[ ${#outdated_in_list[@]} -gt 0 ]]; then
      local temp_json=$(mktemp)
      local brew_info_cmd
      brew_info_cmd="brew info --json=v2 --${package_type} $(printf '%s ' "${outdated_in_list[@]}") > '$temp_json'"
      show_spinner "Fetching version info for ${#outdated_in_list[@]} outdated ${package_type}s" "$brew_info_cmd" 15
      brew_json=$(cat "$temp_json")
      rm -f "$temp_json"
    fi
  fi

  # Arrays to group packages by status
  local -a uptodate_packages=()
  local -a outdated_packages=()
  local -a not_installed_packages=()

  # Categorize packages
  for app in "${brew_apps[@]}"; do
    # Extract current version (if installed)
    local app_info='' current_version=''
    app_info=$(echo "$installed_apps" | grep "^${app} " || true)
    current_version=$(echo "$app_info" | awk '{print $2}' || true)

    if [[ -n "$app_info" ]]; then
      # Check if it's outdated
      local latest_version='' is_outdated=''
      is_outdated=$(echo "$outdated_apps" | grep "^${app}$" || true)
      
      if [[ -n "$is_outdated" && -n "$brew_json" ]]; then
        # Extract latest version from pre-fetched JSON data
        if [[ "$package_type" == "cask" ]]; then
          latest_version=$(echo "$brew_json" | yq -r ".casks[] | select(.token == \"$app\") | .version" 2>/dev/null || true)
        else
          latest_version=$(echo "$brew_json" | yq -r ".formulae[] | select(.name == \"$app\") | .versions.stable" 2>/dev/null || true)
        fi
      fi

      if [[ -n "$latest_version" ]]; then
        # Outdated
        outdated_packages+=("$app ${STYLE[YELLOW]}$current_version${STYLE[RESET]} ${SYMBOL[ARROW]} ${STYLE[LIGHT_GREEN]}$latest_version${STYLE[RESET]}")
      else
        # Up to date
        uptodate_packages+=("$app ${STYLE[LIGHT_GREEN]}$current_version${STYLE[RESET]}")
      fi
    else
      # Not installed
      not_installed_packages+=("$app")
    fi
  done

  # Display packages grouped by status
  echo

  # Show up-to-date packages
  if [[ "$show_outdated" != true ]]; then
    if [[ ${#uptodate_packages[@]} -gt 0 ]]; then
      msg_header h3 --upper "  Up-to-date" "(${#uptodate_packages[@]}):\n"
      for package in "${uptodate_packages[@]}"; do
        msg_success --bold "  $package"
      done
      echo
    fi
  fi
    
  # Show outdated packages
  if [[ ${#outdated_packages[@]} -gt 0 ]]; then
    msg_header h4 --upper "  Outdated ${(C)package_type}s" "(${#outdated_packages[@]}):\n"
    for package in "${outdated_packages[@]}"; do
      msg_warning --bold "  $package"
    done
    echo
  elif [[ "$show_outdated" == true ]]; then
    msg_success --color "  All ${display_name} are up-to-date!"
    echo
  fi

  # Show not installed packages
  if [[ "$show_outdated" != true && ${#not_installed_packages[@]} -gt 0 ]]; then
    msg_header h5 --upper "  Not installed" "(${#not_installed_packages[@]}):\n"
    for package in "${not_installed_packages[@]}"; do
      msg_error --italic "  $package"
    done
  fi
}

# Lists Xcode with status
# @param {boolean} show_outdated - Whether to show only outdated packages
list_xcode() {
  msg_header --underline --upper "\nXcode:\n"
  
  local installed_info
  installed_info=$(mas list | grep "^497799835 " || true)
  if [[ -n "$installed_info" ]]; then
    local current_version is_outdated
    current_version=$(echo "$installed_info" | grep -o '([^)]*)' | sed 's/[()]//g')
    is_outdated=$(mas outdated | grep "^497799835 " || true)
    
    if [[ -n "$is_outdated" ]]; then
      msg_warning "  Xcode ${STYLE[YELLOW]}$current_version"
    else
      msg_success "  Xcode ${STYLE[CYAN]}$current_version"
    fi
  else
    # Not installed
    msg_error --color "  Xcode is not installed."
  fi
}

# Lists Xcode Command Line Tools with status
# @param {boolean} show_outdated - Whether to show only outdated packages
list_xcode_tools() {
  msg_header --upper "\nXcode Command Line Tools:\n"

  local is_installed=false
  local current_version=""
  xcode-select -p &>/dev/null && is_installed=true
  
  if [[ "$is_installed" == true ]]; then
    current_version=$(pkgutil --pkg-info=com.apple.pkg.CLTools_Executables 2>/dev/null | grep version | awk '{print $2}' || true)
    local update_available
    update_available=$(softwareupdate list 2>/dev/null | grep -i "command line tools" || true)
    
    if [[ -n "$update_available" ]]; then
      msg_warning "  Xcode Command Line Tools ${STYLE[CYAN]}$current_version${STYLE[RESET]} â†’ ${STYLE[GREEN]}update available${STYLE[RESET]}"
    else
      msg_success "  Xcode Command Line Tools ${STYLE[CYAN]}$current_version${STYLE[RESET]}"
    fi
  else
    msg_error --color "  Xcode Command Line Tools is not installed."
  fi
}

# Performs all updates of packages and applications.
# This includes brew, npm, zsh, pip, and macOS specific updates.
# @returns {number} 0 on success, 1 on error
update_all() {
  msg_header --upper --underline "\nPerforming All Updates:"

  update_formulas
  update_npm

  # ZSH
  show_spinner "Updating Oh My Zsh" "omz update"  # it returns false even when success, so no &&
  show_spinner "Updating Zinit" "zinit update"

  # PIP
  show_spinner "Updating PIP" "pip3 install --upgrade pip"

  # MACOS
  # -----
  # CLI Tools without full Xcode
  if [[ "$OSTYPE" == "darwin"* ]]; then
    update_xcode_tools
    update_casks
    update_appstore
  fi
}

# Performs all installations of packages and applications.
# This includes brew, npm, and macOS specific installations.
# @returns {number} 0 on success, 1 on error
install_all() {
  msg_header --upper --underline "\nPerforming All Installations:"

  install_formulas
  install_npm_apps

  # MACOS
  # -----
  if [[ "$OSTYPE" == "darwin"* ]]; then
    install_xcode_tools
    install_casks
    install_appstore_apps
  fi
}

# Main script execution function.
# It parses command-line arguments and calls the corresponding functions.
# If no arguments are provided, it displays the help message.
main() {
  # Run dependency check at the start of execution.
  if [[ "$1" != "completions" ]]; then
    echo
    # show_logo
    check_dependencies
    check_applist_file
  fi

  local show_outdated=false
  if [[ "$2" == "outdated" ]]; then
    show_outdated=true
  fi

  if [ "$#" != 0 ]; then
    # If applist file is missing or invalid, exit early.
    [ ! -f "$APPLIST" ] && return 1

    # Handle app add/remove mode commands
    case "$1" in
      -a|add)
        if [ "$#" -ne 3 ]; then
          msg_error "Add requires an <app name> and a <category>."
          return 1
        fi
        manage_applist "add" "$2" "$3"
        return 0
        ;;
      -r|remove)
        if [ "$#" -ne 3 ]; then
          msg_error "Remove requires an <app name> and a <category>."
          return 1
        fi
        manage_applist "remove" "$2" "$3"
        return 0
        ;;
    esac

    # Handle other commands
    for arg in "$@"; do
      case "$arg" in
        "-h"|"--help"|"help")
          show_help
          ;;
        "-l"|"list"|"list-all")
          list_npm "$show_outdated"
          list_brew "formula" "$show_outdated"
          list_brew "cask" "$show_outdated"
          list_appstore "$show_outdated"
          list_xcode "$show_outdated"
          list_xcode_tools "$show_outdated"
          return 0
          ;;
        "list-npm")
          list_npm "$show_outdated"
          return 0
          ;;
        "list-brew-formulas"|"list-formulas")
          list_brew "formula" "$show_outdated"
          return 0
          ;;
        "list-brew-casks"|"list-casks")
          list_brew "cask" "$show_outdated"
          return 0
          ;;
        "list-appstore")
          list_appstore "$show_outdated"
          return 0
          ;;
        "list-xcode")
          list_xcode "$show_outdated"
          return 0
          ;;
        "list-xcode-tools")
          list_xcode_tools "$show_outdated"
          return 0
          ;;
        "update-all")
          update_all
          return 0
        ;;
        "update-npm")
          update_npm
          return 0
        ;;
        "update-formulas")
          update_formulas
          return 0
        ;;
        "update-casks")
          update_casks
          return 0
          ;;
        "update-appstore")
          update_appstore
          return 0
          ;;
        "update-xcode-tools")
          update_xcode_tools
          return 0
        ;;
        "update-xcode")
          update_xcode
          return 0
          ;;
        "install-all")
          install_all
          return 0
          ;;
        "install-npm")
          install_npm_apps
          return 0
          ;;
        "install-formulas")
          install_formulas
          return 0
          ;;
        "install-casks")
          install_casks
          return 0
          ;;
        "install-appstore")
          install_appstore_apps
          return 0
          ;;
        "install-xcode-tools")
          install_xcode_tools
          return 0
          ;;
        "install-xcode")
          install_xcode
          return 0
          ;;
        "completions")
          shell_completions
          ;;
        *)
          msg_error "Invalid option"
          return 1
          ;;
      esac
    done
  else 
    show_help
  fi
}

show_logo() {
  for line in "${LOGO[@]}"; do
    echo -e "$(style_wrap GREEN "${line}")"
  done
}

# Displays the help message with all available options.
show_help() {
  # Get description from package.json
  local description name version website
  description=$(jq -r '.description' < package.json)
  name=$(jq -r '.name' < package.json)
  website=$(jq -r '.homepage' < package.json)
  version=$(jq -r '.version' < package.json) 
  echo
  show_logo
  style_wrap DIM "Version: ${version}"
  style_wrap DIM "Website: ${website}\n"
  style_quote "${description}\n"
  msg_header h2 --upper "Usage:"
  echo -e "  ${name} <command> [options]\n"
  msg_header h2 --upper "Options:"
  echo -e "  -h, help \t\t Show this help message."
  echo -e "  list, list-all \t Lists all apps with status indicators."
  echo -e "  list-npm \t\t Lists all npm packages with status."
  echo -e "  list-brew-formulas \t Lists all brew formulas with status."
  echo -e "  list-brew-casks \t Lists all brew casks with status."
  echo -e "  list-appstore \t Lists all App Store applications with status."
  echo -e "  list-xcode \t\t Lists Xcode info with status."
  echo -e "  list-xcode-tools \t Lists Xcode Command Line Tools info with status."
  echo -e "  outdated \t\t Use with list-* to show only outdated packages.\n"
  echo -e "  add <app> <category>\n\t\t\t Adds an app to a category (npm, appstore, brew, cask)."
  echo -e "  remove <app> <category>\n\t\t\t Removes an app from a category.\n"
  echo -e "  update-all \t\t Performs all updates in sequence."
  echo -e "  update-npm \t\t Updates all global npm packages."
  echo -e "  update-formulas \t\t Updates all brew formulas."
  echo -e "  update-casks \t\t Updates all brew casks."
  echo -e "  update-appstore \t Updates all App Store applications."
  echo -e "  update-xcode \t\t Updates Xcode."
  echo -e "  update-xcode-tools\t Updates Xcode Command Line Tools.\n"
  echo -e "  install-all\t\t Installs all applications and packages."
  echo -e "  install-npm\t\t Installs all global npm packages."
  echo -e "  install-formulas\t\t Installs all brew formulas."
  echo -e "  install-casks\t\t Installs all brew casks."
  echo -e "  install-appstore\t Installs all App Store applications."
  echo -e "  install-xcode\t\t Installs Xcode."
  echo -e "  install-xcode-tools\t Installs Xcode Command Line Tools.\n"
  echo -e "  completions\t\t Generate zsh completion script.\n"
  msg_header h2 --upper "Examples:"
  echo -e "  ${name} list-all"
  echo -e "  ${name} list-npm outdated"
  echo -e "  ${name} list-formulas outdated"
  echo -e "  ${name} upgrade-brew\n"
}

# Generates the shell completion script for this utility.
shell_completions() {
  cat <<'EOF'
autoload -Uz compinit bashcompinit
compinit
bashcompinit

#â€‘completion start
#compdef macos-updatetool

_macos-updatetool() {
  local -a cats
  cats=('appstore:AppStore apps' \
        'npm:NPM packages' \
        'brew:Homebrew formulae' \
        'cask:Homebrew casks')
  
  _arguments -C -s -S \
    '1:options:->opt' \
    '*: : ->args'

  case $state in
    opt)
      _values 'options' \
        'help[-h]' \
        'list[-l]' \
        'list-npm' 'list-brew-formulas' 'list-formulas' 'list-brew-casks' 'list-casks' 'list-appstore' 'list-xcode' 'list-xcode-tools' \
        'outdated' \
        'update-all' \
        'update-npm' 'update-formulas' 'update-casks' 'update-appstore' \
        'update-xcode' 'update-xcode-tools' \
        'install-all' 'install-npm' 'install-formulas' 'install-casks' 'install-appstore' \
        'install-xcode' 'install-xcode-tools' \
        'completions' \
        'add[-a]' \
        'remove[-r]'
      ;;
    args)
      case "${words[2]}" in
        -a|add|-r|remove)
          if (( CURRENT == 3 )); then
            # show placeholder for app name
            _describe 'app name' ''
          elif (( CURRENT == 4 )); then
            # List categories with descriptions
            _describe 'category' cats
            # compadd "${cats[@]}"
          else
            compstate[nolist]=1
          fi
          ;;
        *)
          compstate[nolist]=1
          ;;
      esac
      ;;
  esac
}

compdef _macos-updatetool macos-updatetool
#â€‘completion end
EOF
}

# Start the script by calling the main function with all command-line arguments.
main "$@"

