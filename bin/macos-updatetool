#!/bin/zsh

# A CLI tool that manages apps and packages on macOS.
# It handles Homebrew, npm, App Store apps, and Xcode components.
# Author:
#   John Valai <git@jvk.to>
# License:
#   MIT License
#
# It can upgrade or install applications from multiple sources:
#   * App Store (using mas)
#   * npm
#   * Homebrew (both formulas and casks)
#
# Configuration:
#   * It relies on a file named `applist` (located in the same directory) to know which
#     specific applications and packages to manage.
#
# Dependencies:
#   * Homebrew: For managing formulas and casks.
#   * mas-cli: For managing Mac App Store applications.
#   * npm: For managing global Node.js packages.
#   * Oh My Zsh & zinit: For managing Zsh configuration.
#   * pip3: For managing python packages.
#   * Xcode Command Line Tools: MacOS tool for compiling and installing software.`
#   * softwareupdate: Built-in MacOS tool for system updates.
#
# Usage:
#   macos-updatetool <resource-type> [resource-subtype] <command> [sub-command] [pkg-name...]
#
# Examples:
#   macos-updatetool brew list
#   macos-updatetool brew casks list outdated
#   macos-updatetool appstore update
#   macos-updatetool system list
#   macos-updatetool npm update outdated
#   macos-updatetool all update
#   macos-updatetool brew formulas add git

MODULE_DIR="${0:A:h}"

# Load all modules
for file in "${MODULE_DIR}"/*.zsh; do
  source "${file}" || { echo "FATAL: Cannot load ${file}"; exit 1; }
done

# Initialize configuration system
init_configuration

# Variables defined in sourced files (for ShellCheck)
# shellcheck disable=SC2034  # Variables used throughout script
# RESOURCE_COMMANDS, RESOURCE_ORDER, RESOURCE_SUB_COMMANDS defined in resources.zsh


# Define the path to the applist file using configuration management
APPLIST=$(get_config_value "applist_path")
BACKUP_DIR=$(get_config_value "backup_dir")

LOGO=(
  " █▀▄▀█ ▄▀▀▄ ▄▀▀▄    █  █ ▄▀▀▄ █▀▀▄ ▄▀▀▄ ▀█▀ █▀▀ ▄▀▀▄"
  " █ ▀ █ █▄▄█ █  ▄ ▀▀ █  █ █▄▄█ █  █ █▄▄█  █  █▀▀ █▀▀▄"
  " ▀   ▀ ▀  ▀  ▀▀      ▀▀▀ █    ▀▀▀  ▀  ▀  ▀  ▀▀▀ ▀  ▀"
)
APPLE=(
  '                                 _.'
  '                             _/=\:<'
  '                           //as\@#:'
  '                         *~let:>@'
  '                        (+!:~/+/'
  '                        /={+|'
  '         _.:+*as=._            _.]@~let[._'
  '        .*()/iff{@[[-#>\=.__.<>/#{*+/@*/for=*~.'
  '     [:/@#</>}#for=\>.<:try#>=\*:/[(var<<.+_:#(=.'
  '    #do()=*:.>as//@[]-./[#=+)\(var/@<>[]:-##~/*> '
  '  @#/*-:/#do./@var=\<)]#>/=\>\<for#>|*:try="</'
  '  :/./@#[=#0~as|#:/~/@if.>#[.)=*>/let{}</):\~'
  ' for):/=10#try:</=*;/((+do_1/!"(@~/(1:0>).*}'
  ' /@#: @try*@!\as=\>_@.>#+var>®=>#+-do)=+@#>( '
  ' try@#_<(=</>do#.<30#3\\=~*/()<))_+ 0 #()+1>'
  '  *:#for@:@>):/#<\=*>@|var_J#|[/@*~/.<:if#/~1'
  '  [for()={#in=*:as=\>_@-`>#do/l:/(/[+var)=＠#'
  '   /@[as:=\+@#}=:/let[(=\<_)</@>＃for()=))#>in'
  '    do=~\@#=\><<-))_1#(1)1)_+@let}:[+#=＠/if[()[='
  '     =<})~if/.=＊@var<@:if/(~)=*:/#)=*>@#var<(}if/'
  '      \.=let_0<)#)_=\<~#_)@J+@if#.L+#\|=@#~try/as'
  '         +@>#do(as)*+[＃}=/(/#\<)if).+let:{t.#"'
  '          {}</().try()＃#/as<){*～</>}}(as*>'
  '             "{}<as: "           "*)}do>"'
)

# Renders the ASCII art logo in green.
show_logo() {
  for line in "${LOGO[@]}"; do
    echo -e "$(style_wrap GREEN "${line}")"
  done
}

random_color() {
  echo -e "\e[3$(( ${RANDOM} * 6 / 32767 + 1 ))m"
}

# Render Apple logo with random colors for each character
show_apple_logo() {
  for word in ${APPLE}; do
    for ch in ${(s::)word}; do
      print -n -- "\e[38;5;$((${RANDOM} % 256))m${ch}"
    done
    echo
  done
}

# Entry point: validates environment and arguments, dispatches to resource commands.
# Handles global options, confirmation prompts, and routing to list/install/update flows.
main() {
  if [[ "$1" != "completions" && "$1" != "--version" && "$1" != "-v" && "$1" != "--config" ]]; then
    echo
    check_dependencies
    check_applist_file
  fi

  if [ "$#" = 0 ]; then
    show_help
    exit 0
  fi
  
  local resource_type=""
  local resource_subtype=""
  local command=""
  local pkg_name=""
  local show_outdated=false

  case "$1" in
    -h | --help | help)
      show_help
      exit 0
      ;;
    --version | -v)
      echo
      show_version
      exit 0
      ;;
    --config)
      show_config
      exit 0
      ;;
    --cleanup)
      cleanup_backups
      exit 0
      ;;
    completions)
      shell_completions
      exit 0
      ;;
    *)
    ;;
  esac
  
  # Parse: macupdate <resource-type> [resource-subtype] <command> [sub-command] [pkg-name...]
  resource_type="$1"
  
  # Check for help as last argument at any point
  local last_arg="${*: -1}"
  if [[ "${last_arg}" == "help" ]]; then
    # Remove 'help' from the arguments and show contextual help based on what's provided
    set -- "${@:1:$#-1}"
    
    if [[ -z "$1" ]]; then
      show_help
      exit 0
    elif [[ -n "$1" && -z "$2" ]]; then
      show_contextual_help "command" "$1"
      exit 0
    elif [[ -n "$1" && -n "$2" && -z "$3" ]]; then
      # Handle brew subtype case
      if [[ "$1" == "brew" && ("$2" == "casks" || "$2" == "formulas") ]]; then
        show_contextual_help "command" "$1"
        exit 0
      else
        # $2 is likely a command
        show_contextual_help "sub_command" "$1" "$2"
        exit 0
      fi
    else
      show_help
      exit 0
    fi
  fi
  
  # Validate resource type is provided
  validate_required_argument "resource_type" "${resource_type}" "resource_type"
  shift

  # Validate resource type is supported
  validate_or_error "resource" "${resource_type}" "Unknown resource type: $(style_wrap BOLD "<${resource_type}>")" "resource_type"

  # Handle optional resource-subtype for brew
  if [[ "${resource_type}" == "brew" && ("$1" == "casks" || "$1" == "formulas") ]]; then
    resource_subtype="$1"
    shift
  fi

  # Parse command
  command="$1"
  # Validate command is provided  
  validate_required_argument "command" "${command}" "command" "${resource_type}"
  shift

  # Validate command is supported
  validate_or_error "command" "${command}" "Unknown command: <${command}>" "command" "${resource_type}"

  # Validate command compatibility with resource types
  case "${command}" in
    add | remove)
      # Check if this resource supports add/remove commands
      validate_or_error "resource_command" "${command}" "" "command" "${resource_type}"
      
      # For brew add/remove without subtype, default to formulas
      if [[ "${resource_type}" == "brew" && -z "${resource_subtype}" ]]; then
        resource_subtype="formulas"
      fi
      
      # Collect all remaining arguments as package names
      local -a pkg_names=()
      while [[ $# -gt 0 ]]; do
        pkg_names+=("$1")
        shift
      done
      
      # At least one package name is required for add/remove
      validate_package_names_required "${resource_type}" "${command}" "${pkg_names[@]}"
      ;;
    list | install | update)
      # Handle optional sub-command
      case "$1" in
        outdated)
          # Validate outdated sub-command compatibility
          local sub_commands="${RESOURCE_SUB_COMMANDS[${resource_type}]}"
          if [[ "${sub_commands}" != *"outdated"* ]]; then
            echo
            msg_warning --color "The <outdated> sub-command is not available for resource type $(style_wrap BOLD CYAN "${resource_type}")."
            show_contextual_help "sub_command" "${resource_type}" "${command}"
            exit 1
          fi
          show_outdated=true
          shift
          ;;
        all)
          shift
          ;;
        "")
          # No sub-command specified, default behavior is 'all'
          ;;
        *)
          # If it's not a recognized sub-command, it might be a package name
          # For now, we'll treat unrecognized arguments as invalid
          echo
          msg_error "Invalid sub-command: $1. Valid sub-commands: outdated, all"
          exit 1
          ;;
      esac
      ;;
      *)
      ;;
  esac

  # User confirmation for bulk operations
  if [[ "${resource_type}" == "all" && ("${command}" == "update" || "${command}" == "install") ]]; then
    if ! confirm "This ${command}s all packages in the configuration file. Are you sure?"; then
      exit 0
    fi
  fi

  # Execute commands
  case "${command}" in
    list)
      case "${resource_type}" in
        brew)
          [[ "${resource_subtype}" == "casks" ]] && list_brew "cask" "${show_outdated}"
          [[ "${resource_subtype}" == "formulas" ]] && list_brew "formula" "${show_outdated}"
          [[ -z "${resource_subtype}" ]] && { list_brew "formula" "${show_outdated}"; list_brew "cask" "${show_outdated}"; }
          ;;
        npm) list_npm "${show_outdated}" ;;
        appstore) list_appstore "${show_outdated}" ;;
        xcode) list_xcode ;;
        system) list_xcode_tools ;;
        all)
          list_brew "formula" "${show_outdated}"
          list_brew "cask" "${show_outdated}"
          list_npm "${show_outdated}"
          list_appstore "${show_outdated}"
          # Only show xcode and system if not in outdated mode (they don't support outdated)
          if [[ "${show_outdated}" != true ]]; then
            list_xcode
            list_xcode_tools
          fi
          ;;
        *)
        ;;
      esac
      ;;
    update)
      case "${resource_type}" in
        brew)
          [[ "${resource_subtype}" == "formulas" ]] && update_formulas
          [[ "${resource_subtype}" == "casks" ]] && update_casks
          [[ -z "${resource_subtype}" ]] && { update_formulas; update_casks; }
          ;;
        npm) update_npm ;;
        appstore) update_appstore ;;
        xcode) update_xcode ;;
        system) update_xcode_tools ;;
        all) update_all ;;
        *)
        ;;
      esac
      ;;
    install)
      case "${resource_type}" in
        brew)
          [[ "${resource_subtype}" == "formulas" ]] && install_formulas
          [[ "${resource_subtype}" == "casks" ]] && install_casks
          [[ -z "${resource_subtype}" ]] && { install_formulas; install_casks; }
          ;;
        npm) install_npm_apps ;;
        appstore) install_appstore_apps ;;
        xcode) install_xcode ;;
        system) install_xcode_tools ;;
        all) install_all ;;
        *)
        ;;
      esac
      ;;
    add | remove)
      local target_subtype="${resource_subtype}"
      [[ -z "${target_subtype}" ]] && target_subtype="${resource_type}"
      manage_applist "${command}" "${target_subtype}" "${pkg_names[@]}"
      ;;
    *)
    ;;
  esac
}

# Start the script by calling the main function with all command-line arguments.
main "$@"
